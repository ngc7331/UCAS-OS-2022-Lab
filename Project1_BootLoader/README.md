# Project 1
## 代码说明
注：实验前由老师给出、且未作修改的代码不再说明

注：我将用户程序 (APP) 和批处理 (batch) 统称为任务 (task)，共用`task_info_t`结构存储相关信息，但在内核载入的时候分开存入了两个数组`apps[]`和`batchs[]`

### Bootloader
#### arch/riscv/boot/bootblock.S
载入内核并启动，代码比较简单且对应位置均有注释，不再赘述



### 内核
#### arch/riscv/kernel/head.S
清空bss段，设置栈指针，跳转到内核

#### init/main.c
内核的主程序，启动时：
1. 检查 bss 段
2. 初始化 bios 的函数跳转表
3. 初始化任务信息：
   1. 从镜像固定位置（已载入内存）读取任务信息的位置和数量
   2. 载入任务信息，并根据类型存入`apps[]`和`batchs[]`数组，分别记录数量
4. 遍历所有批处理任务，执行那些被设为自动运行的（`task.execute_on_load==1`），关于批处理文件[见后文](#批处理)
5. 获取一行用户输入
   1. 若为 `help`，输出帮助信息（使用提示和任务列表）
   2. 若为 `batch *`，加载并执行对应批处理
   3. 否则，加载并执行对应用户程序
   4. 若2批处理或3用户程序名无效，报错
6. 从5循环



### 内核库
#### libs/console.c
对`bios_putchar()`等函数的封装，用于读取键盘输入、输出字符到屏幕
- `console_getchar()`：获取一个有效字符（非`-1`）
- `console_parsechar()`：获取一个有效字符，并回显到屏幕，对退格、换行、方向键特殊处理
- `console_getline()`：获取一行输入（读取到换行符，或缓冲区满结束），对退格、方向键特殊处理
- `str_format()`：简单的字符串格式化，把格式串的`_`替换为有效字符，且消除多余`_`
- `console_print()`：对`str_format()`的封装，格式化字符串并打印到屏幕

#### libs/task.c
任务相关函数（不含loader）
- `get_taskid_by_name()`：通过任务名和任务类型返回任务id（即数组下标），无匹配任务返回`-1`
- `run_batch()`：运行批处理

#### libs/task.h
- 任务类型`task_type_t`和任务信息`task_info_t`的类型定义
- 内存地址等宏定义

#### utils.c
实用函数
- `is_space()`：是否为空白字符（目前为制表符`\t`或空格` `）
- `atoi()`：字符串转整型，忽略非数字的字符
- `itoa()`：整型转字符串，支持2、8、10、16进制，支持补零到指定位数
- `[l][r]strip()`：去除字符串左/右/两端的多余空白字符

#### kernel/loader/loader.c
- `load_img()`：对`bios_sdread()`的封装，按字节（而非扇区）读取sd卡到内存，支持两种模式：
  - `copy == 0`：不移动数据，返回`memaddr + offset`，即所需数据的第一个字节存放在内存上的真实位置（`memaddr`处为该字写所在的扇区的第一个字节）。适用于批处理文件、`task_info[]`数组这类对内存地址不敏感的数据
  - `copy == 1`：移动数据，使所需数据的第一个字节存在`memaddr`处，返回`memaddr`。适用于应用程序
- `load_task_img`：对`load_img()`的封装，根据任务id和任务类型加载任务



### 用户程序
#### arch/riscv/crt0/crt0.S
先将返回内核的地址（即进入时`ra`寄存器的值）存入栈中、随后清空bss段、跳转到用户程序的`main()`函数、返回后从栈中读取地址并返回

#### test/test_project1/helloworld.c
调用 bios 输出`[hello] Hello from user app!`



## 使用说明
### OS
`make all`即可编译，环境变量中需要有 riscv64 交叉编译环境
`make run`即可使用 qemu 环境运行，qemu目录位于`~/OSLab-RISC-V/qemu`

#### 使用
输入`loadboot`启动系统

启动时自动运行被设为自动运行（`task.execute_on_load==1`）的批处理任务

当出现`> `时即可输入
- 输入`help`查看提示信息和任务列表
- 输入`batch <batchname>`手动运行批处理任务
- 输入`<appname>`运行用户程序
- 允许前后存在多余空白字符（制表符`\t`或空格` `）

对于特殊字符的处理情况：
- 支持退格键（光标回到行末并删除一个字符）
- 支持左右方向键（左右移后输入时覆盖光标处字符，而非插入，即输入`123[左][左]4`得到的是`143`而非`1423`）
- 禁用上下方向键
- 不支持其它特殊字符，如`delete`、`Ctrl+C`等
- 使用`Ctrl+A X`退出



### 批处理
#### 创建
只需在项目目录中(与 Makefile 同级)创建后缀为`.bat`的文件，文件内容为：
- 第一行为1或0，代表是否在系统启动时自动执行
- 后续每行为一个任务名称
- 允许存在多余空行，任务名称前后允许存在多余制表符`\t`或空格` `

随后运行`make image`即可将批处理写入镜像，无需重新编译内核

目前至多支持16个批处理文件

#### 使用
若批处理文件第一行为1，则系统启动时自动执行

若需手动执行，可以输入`batch <batchname>`即可，其中`batchname`即为文件名，包含`.bat`后缀

亦可输入`help`列出镜像中所有批处理文件

#### 示例
目前已经创建了3个批处理文件，分别是
- `autorun.bat`：演示自动运行
- `manual.bat`：演示非自动运行
- `test.bat`：演示任务名不存在的情况；前后多余空格、空行的情况



## 开发调试过程记录
本次实验整体来说并不算很难，且学案指导也比较充分，大部分编写都很顺利、不值一提。出现bug也大多是由于笔误或者对学案理解错误，例如：

### 在 commit b65ef647 中修复的错误
`lstrip()`用于去除字符串右侧多余的空白字符，机制是：扫描字符串并记录最后一个扫描到的非空白字符的下标，将它作为新的字符串长度，补`\0`，返回

在运行批处理任务时，会调用该函数删除任务名两端多余的空格，但是当某一行只有空格时，预期的逻辑应为：删除空格后字符串长度为0，跳过本行；而实际发生的为：尝试执行任务` `，未找到匹配任务报错。

用 gdb 检查发现删除空格后字符串长度为1，检查逻辑发现`len`（即最后一个非空白字符的下标）的初始值应为`-1`（意为没有非空白字符）而非`0`（意为最后一个非空白字符是`str[0]`）

### 取消应用程序间的 padding
这一要求在学案中的提示并不多，只说要通过`task_info`传递所需参数，按照字节从image中加载任务。然而提供的`bios_sdread()`调用只能按照扇区读取，这是我们无法修改的

一个显然的解决思路是把包含应用程序的所有扇区加载到内存，再将需要的部分复制到正确的内存地址，但这样的复制听上去比较浪费时间，因此我下意识的忽略了这一正确解法

相反，我不假思索的尝试了两个现在看来很离谱的方法：

1. 由于`bios_sdread()`的目标内存地址是按字节寻址的，就让它把数据加载到`memaddr - offset`处，使用户程序的入口加载到目标地址上，类似下图
   ```
   | random bits | user app | random bits |
            0x52000000
   ```
   考虑到每个用户程序运行前都会加载，而内核看起来也占不满`0x50200000-0x52000000`的空间，在尾部覆盖一些垃圾数据应该影响不大

   但事实上，这种做法把数据写入到了未分配给它的内存中，非常危险，而实验也表明这会引起严重的错误

2. 由于跳转到用户程序时，跳转地址是按字节寻址的，就让它跳转到`memaddr + offset`处，内存上的情况类似下图
   ```
        | random bits | user app | random bits |
   0x52000000      +offset
   ```
   但这样也是不可行的，由于在`crt0.S`中清空 bss 段使用了立即寻址，该地址在链接时由链接器根据`riscv.lds`和`USER_ENTRYPOINT`算出。一旦用户程序期望的入口地址与实际加载的内存地址不同，清空 bss 段的逻辑就会清空错误的内存空间，造成错误

最终选择的方式是按上述第2种加载，再使用`memcpy()`将用户程序复制到正确的地址

---
对于这些错误，使用 gdb 单步调试并通过查看变量、寄存器的值辅助检查代码逻辑，很快就能解决。反倒是一些细枝末节的东西比较费力，例如：

### 回车、退格与方向键
最初的版本中，获取用户输入并回显的逻辑是
```c
char ch;
while((ch = bios_getchar()) == -1);
bios_putchar(ch);
return ch;
```

但这样无法处理回车（按下后只是光标回到了行首，并未进入下一行）、退格（无反应）等特殊字符

因此只能特殊处理，通过 gdb 查看变量的值，我获取到了各按键实际输入的 ascii 码值，并用`switch(ch){}`进行分类处理

回车是最容易的，获取到`\n`或`\r`时回显`\n\r`

退格输入的是`127`而非我认为的`\b`，改成获取到`127`时回显`\b`，但这样真的只是“退格”（即光标左移一格），并不能删除屏幕上显示的字符

参考了老师给出的`2048.c`程序，我注意到65行一个`\033[2J`。调研了解到这是 linux 系统的转义符，用途为清屏。但既然是 linux 系统进行处理，我们自制操作系统理应不支持它，我认为可能是现在的 qemu 模拟环境和使用 minicom 连接 pynq 开发板都是运行在 linux 上，而非真实系统的键盘中断+显示驱动，因此能发挥作用，于是我也暂时采用这个方案

了解到`\33[K`作用是清除光标到行末的字符，于是退格的逻辑变为了回显`\b\33[K`，即左移一格并清除光标到行末的字符

但仅仅这样会导致用户可以一直按退格删除所有字符（包括系统打印的），因此必须加上输入缓冲区非空的限制

而方向键的处理更加复杂，通过 gdb 单步调试发现，方向键输入的并非一个字符，而是
```
up:    \033[A
down:  \033[B
right: \033\000[C\000
left:  \033\000[D\000
```
这样的3~5字符序列，因此只能在检测到输入了`\033`后进入特殊的处理流程

接下来又需要考虑方向键和退格键的联合作用，例如用户输入`1[上][退格]`：由于缓冲区内有字符`1`，方向键不改变缓冲区，这个退格自然生效了，而它删除的却是上一行系统输出。且缓冲区内的`1`被删除了、而屏幕上还留着，这个不一致会引起用户误解

再三考虑，我最后的方式是禁用上下键，左右键限制在用户输入区域（通过比较光标位置`i`和两边界`0`及`len`实现），在按下退格时，光标先强制移至行末再删除

该方案不能说是完善，但在现阶段我认为是一个合理的解决方案

也许未来编写 shell 时会有不同的思路

---
总而言之，我体会到了操作系统为了保证鲁棒性、处理各种各样的情况，需要付出的努力绝非一日之事

### 过程复用
最后我还想提一下的是相似过程复用相同代码的措施

这部分是我在 design review 时受到了助教的启发改出的

基本思路是：把需要频繁使用的过程封装成一个函数，通过调用函数减少重复代码；合并相似的结构

例如在 commit d05836c1 以前，我的批处理和用户程序信息分别用一种结构保存，在 image 中也分开存放，但事实上两者的很多域是重合的：任务名、物理地址、文件大小。因此可以合并为同一种结构，另增一个域用来标识它的具体类型，便于 kernel 分开处理

再如从 sd 卡加载 taskinfo 数组、加载用户程序、加载批处理任务，都需要经历：根据物理地址计算起始扇区、根据大小计算扇区数、调用 bios。因此可将该过程封装成一个函数，这就是`loader.c`中的`load_img()`
